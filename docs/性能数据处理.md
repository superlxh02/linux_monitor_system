# 性能数据处理（Manager 侧）

本文说明 **Manager 如何处理 Worker 上报的 `MonitorInfo` 并写入 MySQL**，重点覆盖：

- 接收链路
- 数据清洗与聚合
- 评分与变化率计算
- 各类数据写入哪些表、怎么写

---

## 1. 处理总流程

整体链路：

1. Worker 周期调用 gRPC `SetMonitorInfo(MonitorInfo)`。
2. Manager 的 `GrpcServerImpl::SetMonitorInfo` 接收请求并缓存一份。
3. `SetMonitorInfo` 触发回调，把数据交给 `HostManager::on_data_received`。
4. `HostManager` 生成主机唯一标识、计算评分、计算变化率。
5. `HostManager::write_to_mysql` 将数据写入：
   - `server_performance`（汇总主表）
   - `server_cpu_core_detail`
   - `server_net_detail`
   - `server_softirq_detail`
   - `server_mem_detail`
   - `server_disk_detail`

对应代码：

- 接收：`manager/src/rpc/grpc_server.cpp`
- 处理与写库：`manager/src/host_manager.cpp`
- 服务组装：`manager/manager.cpp`
- 表结构：`manager/sql/server.sql`

---

## 2. 接收阶段（GrpcServerImpl）

### 2.1 接收与校验

`GrpcServerImpl::SetMonitorInfo` 主要逻辑：

- 校验 `request` 非空
- 取主机名：优先 `request->name()`，否则 `request->host_info().hostname()`
- 若主机名缺失返回 `INVALID_ARGUMENT`

### 2.2 缓存与回调

- 将数据存入 `_host_data[hostname] = {info, timestamp}`（内存缓存）
- 若配置了 `_callback`，执行回调
- 在 `manager/manager.cpp` 中，这个回调绑定到：
  `HostManager::on_data_received(info)`

说明：`GrpcServerImpl` 负责“收包 + 轻量缓存”，实际业务处理放在 `HostManager`，实现接收与业务解耦。

---

## 3. 处理阶段（HostManager::on_data_received）

### 3.1 生成服务器唯一标识

优先使用 `host_info` 拼接：

- `hostname + "_" + ip`（例如 `node1_192.168.1.10`）
- 其次 hostname
- 再次 ip
- 最后回退旧字段 `name`

### 3.2 性能评分模型（易懂版）

这一节解释“拿到一台 Worker 的实时数据后，如何算出一个 0~100 的健康分”。

#### 3.2.1 为什么要做评分

单个指标（比如 CPU）只能反映一个侧面，调度或选优时更需要一个综合结论。
因此 Manager 把 CPU、内存、负载、磁盘、网络合成为一个分数：

- 分数越高：机器越空闲，越适合承接新请求
- 分数越低：机器越繁忙，资源越紧张

#### 3.2.2 选取的基础指标

当前实现选取：

- CPU 使用率（`PCPU`）
- 内存使用率（`PMEM`）
- 1 分钟负载（`PLOAD`）
- 磁盘利用率（`PDISK`）
- 网络接收/发送速率（`PINET`、`PONET`）

其中：

- `PLOAD,max = CPU核心数 × N`，当前代码按 I/O 场景取 `N=1.5`
- `PINET,max` 和 `PONET,max` 用带宽上限近似，当前代码用 `1Gbps ≈ 125000000 B/s`

#### 3.2.3 反向归一化（核心思想）

为了让“越空闲分越高”，先把每个指标映射到 `[0,1]`：

| 指标       | 符号      | 归一化得分                      |
| ---------- | --------- | ------------------------------- |
| CPU 使用率 | `PCPU`  | `SCPU = 1 - PCPU/100`         |
| 内存使用率 | `PMEM`  | `SMEM = 1 - PMEM/100`         |
| CPU 负载   | `PLOAD` | `SLOAD = 1 - PLOAD/PLOAD,max` |
| 磁盘利用率 | `PDISK` | `SDISK = 1 - PDISK/100`       |
| 网络收速率 | `PINET` | `SINET = 1 - PINET/PINET,max` |
| 网络发速率 | `PONET` | `SONET = 1 - PONET/PONET,max` |

然后对每个子分数做截断（clamp），确保在 `[0,1]`：

- 小于 0 记为 0
- 大于 1 记为 1

> 说明：你原文中的 `SDISK=(1-PDISK)*100%` 在量纲上不统一。若 `PDISK` 本身是百分比（0~100），应写成 `1 - PDISK/100`，这与当前代码一致。

#### 3.2.4 多评分体系（按业务场景切换）

当前实现支持 4 套通用评分体系，前端可切换，后端查询按所选体系返回分数：

| 评分体系             | 适用场景         |  CPU | 内存 | 负载 | 磁盘 | 网络 | 负载系数N |
| -------------------- | ---------------- | ---: | ---: | ---: | ---: | ---: | --------: |
| `BALANCED`         | 通用均衡（默认） | 0.35 | 0.30 | 0.15 | 0.15 | 0.05 |       1.5 |
| `HIGH_CONCURRENCY` | Web/API 高并发   | 0.45 | 0.25 | 0.15 | 0.10 | 0.05 |       1.2 |
| `IO_INTENSIVE`     | DB/存储 I/O 密集 | 0.20 | 0.15 | 0.20 | 0.35 | 0.10 |       2.0 |
| `MEMORY_SENSITIVE` | 缓存/大内存场景  | 0.20 | 0.45 | 0.15 | 0.10 | 0.10 |       1.5 |

说明：

- 负载归一化使用 `PLOAD,max = CPU核心数 × N`
- 网络上限使用 `PINET,max=PONET,max=125000000 B/s`（1Gbps）
- 反向归一化规则不变，只是权重与 `N` 随场景变化

#### 3.2.5 综合得分公式

先算 0~1 的加权和：

\[S = w_{cpu}\cdot SCPU + w_{mem}\cdot SMEM + w_{load}\cdot SLOAD + w_{disk}\cdot SDISK + w_{net}\cdot\frac{SINET+SONET}{2}]再映射到 0~100：
\[Score = 100\cdot S]

展开形式（统一写法）：
\[Score = 100\cdot\Big(w_{cpu}(1-\frac{PCPU}{100}) + w_{mem}(1-\frac{PMEM}{100}) + w_{load}(1-\frac{PLOAD}{PLOAD,max}) + w_{disk}(1-\frac{PDISK}{100}) + \frac{w_{net}}{2}(1-\frac{PINET}{PINET,max}) + \frac{w_{net}}{2}(1-\frac{PONET}{PONET,max})\Big)]

其中 `w_*` 由上表中的评分体系决定。

#### 3.2.6 怎么看这个分数

- `80~100`：状态健康，可优先分流
- `60~80`：负载上升，建议观察
- `<60`：资源紧张，建议降权或切流

阈值可按业务峰值和 SLA 再调，不是固定标准。

### 3.3 计算主表变化率

使用 `last_perf_samples[host_name]` 与当前值做相对变化率：
\[rate = \begin{cases}
0, & last=0 \\
\frac{now-last}{last}, & last\neq 0
\end{cases}]

用于生成：

- CPU/Load/Mem/Net 的 `*_rate`
- 再写入主表 `server_performance`

### 3.4 更新在线主机状态

- `_host_scores[host_name] = {info, score, now}`
- 后台线程 `process_for_loop` 每 60 秒清理超过 60 秒未更新的主机

---

## 4. 写库阶段（HostManager::write_to_mysql）

`write_to_mysql` 每次收到一条上报会新建 MySQL 连接，按顺序插入多张表。

> 连接配置（代码常量）：
> `host=127.0.0.1, user=monitor, pass=monitor123, db=monitor_db`

### 4.1 server_performance（汇总主表）

写入来源：

- CPU：取 `info.cpu_stat(0)` 的百分比字段
- Load：`info.cpu_load`
- Mem：`info.mem_info`
- Disk：各磁盘 `util_percent` 的最大值
- Net：取 `info.net_info(0)`，并换算到 `kB/s`
- Score：`calc_scores` 结果
- 各类变化率：来自 `on_data_received` 的差分结果 + 本函数内 `disk_util_percent_rate`

说明：这是查询性能趋势、异常、评分排行的核心表。

### 4.2 server_cpu_core_detail（CPU 核心明细）

遍历 `info.cpu_stat`：

- 跳过空核名和总核名 `cpu`
- 每个核心一条记录，写入各百分比字段与时间戳

### 4.3 server_net_detail（网络明细）

遍历 `info.net_info` 每个网卡：

- 写入当前值：
  - `err_in/err_out/drop_in/drop_out`
  - `rcv_bytes_rate/rcv_packets_rate/snd_bytes_rate/snd_packets_rate`
- 用缓存 `last_net_samples[host][net]` 计算变化率：
  - 速率变化：`rate(curr_rate, last_rate)`
  - 错误/丢弃变化：`rate_u64(curr, last)`

### 4.4 server_softirq_detail（软中断明细）

遍历 `info.soft_irq` 每个 CPU：

- 写入当前 softirq 指标（`hi/timer/net_tx/.../rcu`）
- 用 `last_softirq_samples[host][cpu]` 计算各字段变化率

### 4.5 server_mem_detail（内存明细）

若 `info.has_mem_info()`：

- 写入所有内存分项（`total/free/avail/buffers/...`）
- 用 `last_mem_samples[host]` 计算每个字段的变化率

### 4.6 server_disk_detail（磁盘明细）

遍历 `info.disk_info` 每块磁盘：

- 写入原始计数器（`reads/writes/sectors...`）
- 写入 worker 已计算好的派生指标（`read_bytes_per_sec/read_iops/util_percent...`）
- 用 `last_disk_samples[host][disk]` 计算派生指标变化率

---

## 5. 各类 Worker 数据在 Manager 的落库映射

### 5.1 CPU

- 来源：`CpuStatMonitor`（worker）
- Manager 处理：
  - 汇总：取 `cpu_stat(0)` 进 `server_performance`
  - 明细：所有核心进 `server_cpu_core_detail`

### 5.2 CPU Load

- 来源：`CpuLoadMonitor`
- Manager 处理：
  - 写 `server_performance.load_avg_1/3/15`
  - 计算对应 `load_avg_*_rate`

### 5.3 SoftIRQ

- 来源：`CpuSoftIrqMonitor`
- Manager 处理：
  - 每 CPU 写 `server_softirq_detail`
  - 按上次样本算各 softirq 类型变化率

### 5.4 Memory

- 来源：`MemoryMonitor`
- Manager 处理：
  - 汇总项（used/total/free/avail）写 `server_performance`
  - 全量分项写 `server_mem_detail`
  - 汇总与明细都计算变化率

### 5.5 Network

- 来源：默认 `NetEbpfMonitor`
- Manager 处理：
  - 汇总：只取第一块网卡写 `server_performance.send_rate/rcv_rate`
  - 明细：所有网卡写 `server_net_detail`
  - 明细表记录错误/丢弃计数及变化率

### 5.6 Disk

- 来源：`DiskMonitor`
- Manager 处理：
  - 汇总：取最大 `util_percent` 写 `server_performance.disk_util_percent`
  - 明细：每块盘写 `server_disk_detail`
  - 明细记录 worker 派生指标及变化率

---

## 6. 关键实现特征（当前版本）

1. 变化率统一采用相对变化：`(now-last)/last`，当 `last=0` 返回 0。
2. 写库时使用字符串拼接 SQL 并逐条 `INSERT`。
3. 每次 `write_to_mysql` 新建/关闭一次 MySQL 连接。
4. 汇总表网络与 CPU 取“首条”数据（`net_info(0)`、`cpu_stat(0)`），明细表保留全量。
5. 缓存容器（`last_*_samples`）在进程内存中，重启后变化率基线重置。

---

## 7. 小结

Manager 对 Worker 上报数据采用“**接收回调驱动 + 汇总表/明细表双层落库**”模式：

- `GrpcServerImpl` 负责稳定接收
- `HostManager` 负责业务计算（评分、变化率、主机状态）
- `write_to_mysql` 负责按数据类型拆分写入多张表

这样既支持快速查询（汇总表），也支持深度排障（明细表）。
