# 性能数据说明

本文说明 Worker 采集并上报到 `MonitorInfo` 的性能数据：

- 统计了哪些结构体与字段
- 字段语义是什么
- 这些字段由哪个 Monitor 计算
- 关键计算公式是什么

---

## 1. 总览：MonitorInfo 结构体

`proto/monitor_info.proto` 中 `MonitorInfo` 是 Worker 单次采集上报的总包，包含：

- `name`：主机名（兼容字段）
- `host_info`：主机标识（hostname、ip）
- `cpu_load`：平均负载
- `cpu_stat`（repeated）：每核 CPU 状态百分比
- `soft_irq`（repeated）：每核软中断统计
- `mem_info`：内存统计
- `net_info`（repeated）：网卡网络统计
- `disk_info`（repeated）：磁盘统计

在 `worker/src/monitor/metric_collector.cpp` 中，当前默认启用的 Monitor 顺序为：

1. `CpuLoadMonitor`
2. `CpuStatMonitor`
3. `CpuSoftIrqMonitor`
4. `MemoryMonitor`
5. `NetEbpfMonitor`
6. `DiskMonitor`
7. `HostInfoMonitor`

---

## 2. HostInfo（主机标识）

### 2.1 结构体

来源：`proto/monitor_info.proto` 中 `HostInfo`

- `hostname`：主机名
- `ip_address`：主网卡 IPv4

### 2.2 由谁计算

- `worker/src/monitor/hostinfo_monitor.cpp` (`HostInfoMonitor`)

### 2.3 如何得到

- 主机名：`gethostname()`
- IP：遍历 `getifaddrs()`，筛选 IPv4，跳过 `lo` 和常见虚拟网卡（docker/veth/br-/virbr），取第一个有效地址
- 结果缓存：仅首次采集时获取，后续复用缓存

---

## 3. CpuLoad（系统负载）

### 3.1 结构体

来源：`proto/cpu_load.proto`

- `load_avg_1`：1 分钟平均负载
- `load_avg_3`：3 分钟平均负载
- `load_avg_15`：15 分钟平均负载

### 3.2 由谁计算

- `worker/src/monitor/cpuload_monitor.cpp` (`CpuLoadMonitor`)

### 3.3 如何得到

优先级：

1. 优先从 `/dev/cpu_load_monitor`（内核模块）`mmap` 读取
2. 失败则回退到 `/proc/loadavg`

说明：该类字段是“系统已计算好的瞬时窗口均值”，Worker 不再做差分换算。

---

## 4. CpuStat（每核 CPU 百分比）

### 4.1 结构体

来源：`proto/cpu_stat.proto`

- `cpu_name`
- `cpu_percent`
- `usr_percent`
- `system_percent`
- `nice_percent`
- `idle_percent`
- `io_wait_percent`
- `irq_percent`
- `soft_irq_percent`

### 4.2 由谁计算

- `worker/src/monitor/cpustate_monitor.cpp` (`CpuStatMonitor`)

### 4.3 数据来源

- `/dev/cpu_stat_monitor`（内核模块导出的 mmap 设备）
- 内核提供的是累计时间计数（非百分比）

### 4.4 计算方式

对每个 CPU，取“本次累计值”和“上次累计值”做差：

- 总时间：
  \[total = user + system + idle + nice + iowait + irq + softirq + stea]
- 忙碌时间：
  \[busy = user + system + nice + irq + softirq + stea]

百分比：
\[cpu\_percent = \frac{\Delta busy}{\Delta total} \times 10]
\[usr\_percent = \frac{\Delta user}{\Delta total} \times 10]
其余 `system/nice/idle/io_wait/irq/soft_irq` 同理。

实现细节：

- 首次采样只建立缓存，不输出有效差分百分比
- 设备不存在时做 30 秒节流重试

---

## 5. SoftIrq（每核软中断）

### 5.1 结构体

来源：`proto/cpu_softirq.proto`

- `cpu`
- `hi`
- `timer`
- `net_tx`
- `net_rx`
- `block`
- `irq_poll`
- `tasklet`
- `sched`
- `hrtimer`
- `rcu`

### 5.2 由谁计算

- `worker/src/monitor/cpusoftirq_monitor.cpp` (`CpuSoftIrqMonitor`)

### 5.3 数据来源

- `/dev/cpu_softirq_monitor`（内核模块导出的 mmap 设备）
- 内核提供的是每类 softirq 的累计计数

### 5.4 计算方式

若存在历史样本：
\[rate = \frac{current - last}{\Delta t}\quad(\text{次/秒})]
其中 `Δt` 使用毫秒差换算为秒。

实现细节：

- 有历史样本时，字段写入每秒速率
- 首次采样或 `Δt<=0` 时，回填累计值（用于避免除零）

---

## 6. MemInfo（内存）

### 6.1 结构体

来源：`proto/mem_info.proto`

- `total/free/avail`
- `buffers/cached/swap_cached`
- `active/inactive`
- `active_anon/inactive_anon`
- `active_file/inactive_file`
- `dirty/writeback`
- `anon_pages/mapped`
- `kReclaimable/sReclaimable/sUnreclaim`
- `used_percent`

### 6.2 由谁计算

- `worker/src/monitor/memory_monitor.cpp` (`MemoryMonitor`)

### 6.3 数据来源

- `/proc/meminfo`

### 6.4 计算方式

- `used_percent`：
  \[used\_percent = \frac{total - avail}{total} \times 100]
- 其余字段：从 `/proc/meminfo` 读取后换算单位写入（代码当前按 `KB / (1000*1000)` 转成 GB）

说明：这是“瞬时快照型”指标，不依赖历史差分。

---

## 7. NetInfo（网络）

### 7.1 结构体

来源：`proto/net_info.proto`

- `name`
- `send_rate`
- `rcv_rate`
- `send_packets_rate`
- `rcv_packets_rate`
- `err_in/err_out/drop_in/drop_out`

### 7.2 由谁计算

当前默认启用：

- `worker/src/monitor/net_ebpf_monitor.cpp` (`NetEbpfMonitor`)

备用实现（当前未在 collector 中启用）：

- `worker/src/monitor/net_monitor.cpp` (`NetMonitor`，基于 `/proc/net/dev`)

### 7.3 数据来源（默认 eBPF）

- eBPF 程序挂载 TC ingress/egress
- BPF map 按 `ifindex` 维护累计：
  - `rcv_bytes/rcv_packets`
  - `snd_bytes/snd_packets`

### 7.4 计算方式（默认 eBPF）

对同一网卡：
\[byte\_rate = \frac{\Delta bytes}{\Delta t}\quad,\quad pkt\_rate = \frac{\Delta packets}{\Delta t}]
实现中 `Δt` 取毫秒并换算为每秒；首次采样速率为 0。

注意：

- `NetEbpfMonitor` 当前主要填充速率字段
- `err_in/err_out/drop_in/drop_out` 在默认 eBPF 路径下未填充（备用 `NetMonitor` 会填）
- `proto` 注释写的是 `kB/s`，但 eBPF 实现当前按字节差直接换算每秒，展示层建议统一单位口径

---

## 8. DiskInfo（磁盘）

### 8.1 结构体

来源：`proto/disk_info.proto`

累计快照字段：

- `name`
- `reads/writes`
- `sectors_read/sectors_written`
- `read_time_ms/write_time_ms`
- `io_in_progress/io_time_ms/weighted_io_time_ms`

派生速率字段：

- `read_bytes_per_sec`
- `write_bytes_per_sec`
- `read_iops`
- `write_iops`
- `avg_read_latency_ms`
- `avg_write_latency_ms`
- `util_percent`

### 8.2 由谁计算

- `worker/src/monitor/disk_monitor.cpp` (`DiskMonitor`)

### 8.3 数据来源

- `/proc/diskstats`
- 跳过 `loop*` 与 `ram*` 设备

### 8.4 计算方式

设 `Δt` 为秒：

- 字节吞吐：
  \[read\_bytes\_per\_sec = \frac{\Delta sectors\_read \times 512}{\Delta t]
  \[write\_bytes\_per\_sec = \frac{\Delta sectors\_written \times 512}{\Delta t}]
- IOPS：
  \[read\_iops = \frac{\Delta reads}{\Delta t},\quad write\_iops = \frac{\Delta writes}{\Delta t}]
- 平均时延：
  \[avg\_read\_latency\_ms = \frac{\Delta read\_time\_ms}{\Delta reads}]
  \[avg\_write\_latency\_ms = \frac{\Delta write\_time\_ms}{\Delta writes}]
- 利用率：
  \[util\_percent = \frac{\Delta io\_time\_ms}{\Delta t \times 10}]
  等价于 \(\frac{\Delta io\_time\_ms}{\Delta t \times 1000}\times100\%\)。

实现细节：首次采样无历史样本时，速率类字段置 0。

---

## 9. 计算模式总结（按 Monitor）

- 差分型（依赖历史缓存）：
  - `CpuStatMonitor`
  - `CpuSoftIrqMonitor`
  - `NetEbpfMonitor`
  - `DiskMonitor`
- 快照型（直接读取当前值）：
  - `CpuLoadMonitor`
  - `MemoryMonitor`
  - `HostInfoMonitor`

差分型通用模板：
\[metric\_rate = \frac{current - last}{\Delta t}]
或
\[metric\_percent = \frac{\Delta part}{\Delta total}\times 100]

---

## 10. 备注与口径建议

1. 单位统一建议：
   - 网络速率建议统一明确为 `B/s` 或 `kB/s`，并在 proto 注释、后端实现、前端展示三处保持一致。
2. 首次采样语义：
   - 差分型指标第一帧通常不是“真实速率”，建议前端可选择淡化或忽略首帧。
3. 可用性降级：
   - CPU 状态/软中断依赖内核模块设备节点
   - 网络 eBPF 依赖 root/CAP_BPF/CAP_NET_ADMIN
   - 不可用时对应字段会缺失或为 0，应在展示层做容错
